<!-- build time:Mon Mar 29 2021 14:07:05 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html><head><meta charset="utf-8"><title>java笔记 | Zhy Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="前言Java语言是美国Sun公司（stanford University Network）在1995年推出的高级编程语言。2009年Oracle甲骨文公司收购Sun公司，并于2011年发布java7版本JVM、JRE、JDKJVM（java Virtual Machine）：Java编写的软件可以运行在任何操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行"><meta property="og:type" content="article"><meta property="og:title" content="java笔记"><meta property="og:url" content="https:&#x2F;&#x2F;liserlzhy.github.io&#x2F;2020&#x2F;06&#x2F;10&#x2F;java&#x2F;java&#x2F;index.html"><meta property="og:site_name" content="Zhy Blog"><meta property="og:description" content="前言Java语言是美国Sun公司（stanford University Network）在1995年推出的高级编程语言。2009年Oracle甲骨文公司收购Sun公司，并于2011年发布java7版本JVM、JRE、JDKJVM（java Virtual Machine）：Java编写的软件可以运行在任何操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;liserlzhy.github.io&#x2F;blog&#x2F;2020&#x2F;06&#x2F;10&#x2F;java&#x2F;java&#x2F;javarel.png"><meta property="og:image" content="https:&#x2F;&#x2F;liserlzhy.github.io&#x2F;blog&#x2F;2020&#x2F;06&#x2F;10&#x2F;java&#x2F;java&#x2F;colleciton.png"><meta property="og:updated_time" content="2021-03-29T14:06:46.221Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;liserlzhy.github.io&#x2F;blog&#x2F;2020&#x2F;06&#x2F;10&#x2F;java&#x2F;java&#x2F;javarel.png"><link rel="alternate" href="/blog/atom.xml" title="Zhy Blog" type="application/atom+xml"><link rel="icon" href="/blog/css/images/logo.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/blog/css/style.css"><meta name="generator" content="Hexo 4.0.0"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="slideout-menu"><ul><li><a class="main-nav-link" href="/blog/">首页</a></li><li><a class="main-nav-link" href="/blog/archives">归档</a></li><li><a class="main-nav-link" href="/blog/favorite">收藏</a></li><li><div class="site_search"><div class="form-group"><input type="text" id="slidedown-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"></div><div id="slidedown-search-result"></div></div></li></ul></div><nav id="header-nav"><div id="logo-img"><label class="on-off noselect" for="on-off"><input id="on-off" type="checkbox" onchange='return window.location="/blog/"'> <span class="on-off-circle"></span></label></div><div id="menu-icon"><a class="icon icon-bars"></a></div><ul><li><a class="main-nav-link" href="/blog/">首页</a></li><li><a class="main-nav-link" href="/blog/archives">归档</a></li><li><a class="main-nav-link" href="/blog/favorite">收藏</a></li><li><div id="search-icon"><a class="icon icon-search" title="搜索"></a></div></li></ul></nav><div class="site_search"><div><input type="text" id="nav-search-input" name="q" results="0" placeholder="搜索"></div><div id="nav-search-result"></div></div></header><div class="outer"><div class="toc-post"><div id="toc" class="toc-article"><span id="toc-icon" class="icon icon-chevron-right"></span><div id="toc-box"><div class="toc-title">java笔记</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM、JRE、JDK"><span class="toc-text">JVM、JRE、JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量分类"><span class="toc-text">常量分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用变量的注意事项"><span class="toc-text">使用变量的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDEA常用快捷键"><span class="toc-text">IDEA常用快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重载"><span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存划分"><span class="toc-text">Java内存划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量与成员变量"><span class="toc-text">局部变量与成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#权限修饰符"><span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-text">内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scanner"><span class="toc-text">Scanner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random"><span class="toc-text">Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-常见方法"><span class="toc-text">String 常见方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays"><span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-text">Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-text">Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDateFormat"><span class="toc-text">SimpleDateFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar-抽象类"><span class="toc-text">Calendar 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System"><span class="toc-text">System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-text">StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包装类"><span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#装箱与拆箱"><span class="toc-text">装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换-1"><span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection集合"><span class="toc-text">Collection集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator接口-迭代器"><span class="toc-text">Iterator接口 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型"><span class="toc-text">泛型</span></a></li></ol></div></div><article id="post-java/java" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><time class="article-date" datetime="2020-06-10T23:18:58.000Z" itemprop="datePublished">2020-06-10</time></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">java笔记</h1></header><div class="article-entry" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java语言是美国Sun公司（stanford University Network）在1995年推出的高级编程语言。2009年Oracle甲骨文公司收购Sun公司，并于2011年发布java7版本</p><h3 id="JVM、JRE、JDK"><a href="#JVM、JRE、JDK" class="headerlink" title="JVM、JRE、JDK"></a>JVM、JRE、JDK</h3><ul><li>JVM（java Virtual Machine）：Java编写的软件可以运行在任何操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。</li><li>JRE（Java Runtime Environment）:是Java程序的运行时环境，包括JVM和运行时所需的核心类库。</li><li>JDK（Java Development Kit）:是Java程序开发工具包，包括JRE和开发人员使用的工具</li></ul><p><img src="/blog/2020/06/10/java/java/javarel.png" alt="jdk-jre-jvm关系图"></p><pre><code>编译java程序：javac xxx.java
运行程序：java xxx
java命令行工具：jShell </code></pre><h3 id="常量分类"><a href="#常量分类" class="headerlink" title="常量分类"></a>常量分类</h3><ul><li>字符串常量：<code>&quot;hello world&quot;</code></li><li>整数常量：<code>200</code></li><li>浮点数常量：<code>1.23</code></li><li>字符常量：<code>&#39;a&#39;</code>，注意：单引号括住的单字符，有且只有一个字符，不能为空</li><li>布尔常量：<code>true</code>、<code>false</code></li><li>空常量：null，注意：空常量不能用来打印输出，如：System.out.println(null) //会报错</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li>基本数据类型：</li></ol><ul><li>整数型： byle（1字节）、short（2字节）、int（4字节 默认）、long（8字节）</li><li>浮动型： float（4字节）、double（8字节 默认）</li><li>字符型： char（2字节）</li><li>布尔型： boolean（1字节）<br>注意：<br>(1) 字符串不是基本类型，而是引用类型。<br>(2) 浮动型可能只是一个近似值，并非精确的值。<br>(3) 浮点数默认为double类型，若要使用float类型，需要加后缀F<br>(4) 整数默认为int类型，若要使用long类型，需要加后缀L，推荐大写字母后缀。</li></ul><h3 id="使用变量的注意事项"><a href="#使用变量的注意事项" class="headerlink" title="使用变量的注意事项"></a>使用变量的注意事项</h3><ol><li>如果创建多个变量，那么变量之间的名称不能重复</li><li>对于float和long类型来说，字母后缀F和L不要丢掉</li><li>如果使用byte或者short类型的变量，右侧数值不要超过左侧类型的范围</li><li>变量得初始化后才能使用</li><li>变量的使用不能超出作用域范围，如:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(num1); <span class="comment">// 会出错</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>自动类型转换（隐式）</p><ol><li>特点：代码不需要进行特殊处理，自动完成</li><li>规则：数据范围从小到大<br>注意：范围与字节不一定相关，比如 float num = 100L; long -&gt; float</li></ol><p>强制类型转换</p><ol><li>特点：代码需要进行特殊格式处理，不能自动完成<br>注意：</li><li>强制类型转换一般不推荐使用，因为有可能发生精度损失，数据溢出。</li><li>byte/short/char这三种类型都可以发生数学运算，运算时会被提升成为int类型，然后再计算。</li><li>boolean类型不能发生数据类型转换。</li><li>对于String类型，加号代表字符串连接操作。</li><li>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐式地为我们补上(byte)(short)(char)。如果超过左侧范围，会报错</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">System.out.println(c + <span class="number">1</span>); <span class="comment">// 66， '1' + 0 = 49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> n1 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">byte</span> n2 = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> result = n1 + n2;</span><br><span class="line"><span class="keyword">byte</span> result2 = (<span class="keyword">byte</span>)(n1 + n2);</span><br><span class="line"></span><br><span class="line">String str = <span class="string">"Java"</span>;</span><br><span class="line">System.out.println(str + <span class="number">10</span> + <span class="number">20</span>); <span class="comment">//Java1020</span></span><br></pre></td></tr></table></figure><p>编译器的常量优化：在给变量进行赋值的时候，如果右侧表达式全是常量，那么编译器javac会直接将若干个常量表达式计算得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">short</span> result = a + b; <span class="comment">//会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> result = <span class="number">5</span> + <span class="number">8</span>; <span class="comment">// 相当于 short result = 13;</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>注意事项：</p><ol><li>方法定义无所谓顺序。</li><li>方法的定义不能产生嵌套包含关系。</li><li>不能再一个方法的内部定义另一个方法。</li></ol><h3 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h3><table><thead><tr><th align="left">快捷键</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">Alt+Enter</td><td align="left">导入包自动修正代码</td></tr><tr><td align="left">Ctrl+Y</td><td align="left">删除光标所在行</td></tr><tr><td align="left">Ctrl+D</td><td align="left">复制光标所在行的内容，插入光标位置下面</td></tr><tr><td align="left">Ctrl+Alt+L</td><td align="left">格式化代码</td></tr><tr><td align="left">Ctrl+/</td><td align="left">单行注释，再按取消注释</td></tr><tr><td align="left">Ctrl+Shift+/</td><td align="left">选中代码注释，多行注释，再按取消注释</td></tr><tr><td align="left">Alt+Ins</td><td align="left">自动生成代码，toString，get，set等方法</td></tr><tr><td align="left">Alt+Shift+上下箭头</td><td align="left">移动当前代码行</td></tr></tbody></table><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法名称一样，参数列表不一样</p><p>方法重载与下列因素无关：</p><ol><li>与参数的名称无关。</li><li>与方法的返回值类型无关。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.3</span>,<span class="number">2.1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组初始化</p><p>注意：</p><ul><li>静态初始化虽然没有指定长度，但仍会自动推算得到长度</li><li>静态初始化的省略模式，不能拆分为两个步骤</li><li>直接打印数组名称，得到的是该数组的内存地址哈希值</li><li>动态初始化数组，其中的元素会自动拥有一个默认值：<ul><li>整数类型，默认为0</li><li>浮点数类型，默认为0.0</li><li>布尔类型，默认为false</li><li>字符类型，默认为\u0000</li><li>引用类型，默认为null</li></ul></li><li>静态初始化起始也有默认值，只不过会被具体的内容替代掉<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 动态初始化（指定长度）</span></span><br><span class="line"><span class="comment">// 静态初始化标准模式</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;; <span class="comment">// 静态初始化（指定内容）</span></span><br><span class="line"><span class="comment">// 静态初始化省略模式</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化的省略模式，不能拆分为两个步骤</span></span><br><span class="line"><span class="comment">// int[] arr4;</span></span><br><span class="line"><span class="comment">// arr4 = &#123;3, 1, 3&#125;;  // 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = arr2.length; <span class="comment">// 获取数组的长度</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList<e></e></h3><ul><li>数组的长度不可发生改变</li><li>ArrayList集合的长度可以随意变化</li><li>尖括号代表泛型（即集合中的所有元素都是同一类型）</li><li>泛型只能是引用类型，不能是基本类型</li><li>直接空的ArrayList打印不是地址值，而是[]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Domo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;string&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(list); <span class="comment">// []</span></span><br><span class="line">    list.add(<span class="string">"Tom"</span>); <span class="comment">// add向集合中添加元素</span></span><br><span class="line">    list.add(<span class="string">"Jone"</span>);</span><br><span class="line">    System.out.println(list); <span class="comment">// [Tom, Jone]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>)); <span class="comment">// get获取第一个元素</span></span><br><span class="line"></span><br><span class="line">    list.remove(<span class="number">1</span>); <span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line">    list.size(); <span class="comment">// 获取集合的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望向集合ArrayList当中存储基本数据类型，必须使用基本类型对应的“包装类”</p><table><thead><tr><th align="right">基本类型</th><th align="right">包装类</th></tr></thead><tbody><tr><td align="right">byte</td><td align="right">Byte</td></tr><tr><td align="right">short</td><td align="right">Short</td></tr><tr><td align="right">int</td><td align="right">Integer</td></tr><tr><td align="right">long</td><td align="right">Long</td></tr><tr><td align="right">float</td><td align="right">Float</td></tr><tr><td align="right">double</td><td align="right">Double</td></tr><tr><td align="right">char</td><td align="right">Character</td></tr><tr><td align="right">boolean</td><td align="right">Boolean</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Interger&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">21</span>);</span><br></pre></td></tr></table></figure><h3 id="Java内存划分"><a href="#Java内存划分" class="headerlink" title="Java内存划分"></a>Java内存划分</h3><ol><li><p>栈 (Stack)：存放的都是方法中的局部变量，一旦超出作用域，立刻从栈内存中消失。方法的运行一定要在栈中</p></li><li><p>堆（Heap）：凡是new出来的东西，都在堆中</p></li><li><p>方法区（Method Area）：存储class相关信息，包括方法的信息</p></li><li><p>本地方法栈（Native Method Stack）：与操作系统相关</p></li><li><p>寄存器（pc Register）：与CPU相关</p></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  String brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Phone one = <span class="keyword">new</span> Phone()</span><br><span class="line">System.out.println(one.brand);</span><br></pre></td></tr></table></figure><h3 id="局部变量与成员变量"><a href="#局部变量与成员变量" class="headerlink" title="局部变量与成员变量"></a>局部变量与成员变量</h3><ul><li><p>定义的位置不一样</p><ul><li>局部变量：在方法的内部</li><li>成员变量：在方法的外部，直接写在类当中</li></ul></li><li><p>作用范围不一样</p><ul><li>局部变量：只有方法当中才可以使用。</li><li>成员变量：整个类都可用</li></ul></li><li><p>默认值不一样</p><ul><li>局部变量：没有默认值，必须进行初始化</li><li>成员变量：如果没有赋值，会有默认值，规则跟数组一样</li></ul></li><li><p>内存的位置不一样</p><ul><li>局部变量：位于栈内存</li><li>成员变量：位于堆内存</li></ul></li><li><p>生命周期不一样</p><ul><li>局部变量：随着方法进栈而诞生，随着方法出栈而消失</li><li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</li></ul></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>三大特性：封装、继承、多态</p><p>封装性在Java中的体现：</p><ol><li>方法也是一种封装</li><li>private</li></ol><p>一个标准的类通常要拥有下面四个组成部分：</p><ol><li>所有成员变量都要用private关键字修饰</li><li>为每一个成员变量编写一对儿Getter/Setter方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>注意事项：</p><ol><li>构造方法的名称必须与类名完全一样</li><li>构造方法不要写返回值类型，连void都写</li><li>构造方法不能return一个具体的返回值</li><li>如果没有编写任何构造方法，编译器会默认赠送一个没有参数，方法体啥也不做的构造方法</li><li>一旦编写了至少一个构造方法，那么编译器不再赠送</li><li>构造方法可以重载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造方法执行啦！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造方法</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"Tom"</span>, <span class="number">29</span>);</span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li>如果一个成员变量或者方法使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。</li><li>推荐：类名称.静态方法，类名称.静态变量</li><li>本类当中的静态方法，可以省略类名称</li><li>静态不能直接访问非静态：原因是内存当中先有静态内容，后才有非静态</li><li>静态方法中不能使用this</li></ul><p>静态代码块<br>特点：当第一次用到本类时，静态代码块执行唯一的一次<br>典型用途：用来一次性地对静态成员变量进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态代码块执行"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>重写（Override）：方法名称一样，参数列表也一样。</li><li>重载（Overload）：方法的名称一样，参数列表不一样。</li><li>@Override ：放在方法前面，用来检测是否是有效的正确覆盖重写</li><li>子类方法的返回值必须【小于等于】父类方法的返回值范围</li><li>子类方法的权限必须【大于等于】父类方法的权限修饰符（public &gt; protected &gt; + (default) &gt; private）</li><li>子类构造方法当中有一个默认隐含的”super()”调用，所以一定是先调用父类构造，后执行子类构造。</li><li>只有在子类构造函数中才能调用父类构造函数，而且必须是子类构造方法的第一个语句</li><li>this(…)调用也必须是构造方法的第一个语句，唯一一个</li><li>super和this两种构造不能同时使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// super(); // 如果没写会默认调用父类的构造方法</span></span><br><span class="line">    <span class="comment">// super(12); // 调用父类重载构造</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Tom"</span>); <span class="comment">//调用本类的构造方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">super</span>.num; <span class="comment">// 调用父类的num </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java语言的3个特点：</p><ol><li>Java语言是单继承的，直接父类只能有一个</li><li>Java语言可以多级继承，即父亲也有父亲</li><li>一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类</li><li>子类必须覆盖重写抽象父类当中的所有的抽象方法，除非该子类也是抽象类<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3></li></ol><ul><li>如果父类当中的方法不确定具体实现，那么这应该是一个抽象方法</li><li>抽象方法所在的类必须是抽象类才行</li><li>不能直接创建new抽象类</li><li>必须有一个子类来继承抽象类</li><li>抽象类不一定包含抽象方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是多个类公共规范<br>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法</p><ul><li>如果是java7，接口包括的内容有：常量、抽象方法</li><li>如果是java8，接口额外包含有：默认方法、静态方法</li><li>如果是java9，还可以额外包含：私有方法</li></ul><p>备注：</p><ol><li>接口中的默认方法，可以解决接口升级的问题</li><li>不能通过接口实现类的对象来调用接口当中的静态方法</li><li>接口中也可以定义“成员变量”，但是必须使用public static final来进行修饰。从效果看，这其实就是接口的【常量】</li><li>接口中的常量必须进行赋值</li><li>接口不能有静态代码块和构造方法</li><li>一个类可以实现多个接口：implements MyInterfaceA, MyInterfaceB{}</li><li>如果实现类所实现的多个接口，重复的抽象方法，只需覆盖重写一次即可</li><li>如果实现类没有实现所有接口当中的所有抽象方法，那么实现类必须是一个抽象类</li><li>如果实现类实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</li><li>一个类直接父类当中的方法，与接口当中的默认方法产生冲突，优先用父类当中的方法</li><li>接口可以多继承：public interfae MyInterface extends MyInterfaceA, MyInterfaceB {}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></span><br><span class="line"><span class="comment">2. 这两个关键字（public abstract），可以选择性地省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>; <span class="comment">// 一旦使用final修饰，说明不能改变</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// abstract void methodAbs3();</span></span><br><span class="line">    <span class="comment">// public void methodAbs4();</span></span><br><span class="line">    <span class="comment">// void methodAbs5(); // 这些都是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"这是新添加的默认方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"这是接口的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceAbstractimpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceAbstract</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"必须覆盖重写接口的所有抽象方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDefault03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyInterfaceAbstractimpl a = <span class="keyword">new</span> MyInterfaceAbstract();</span><br><span class="line">        a.methodAbs1();</span><br><span class="line">        a.methodDefault(); <span class="comment">// 如果实现类当中没有，会向上找接口</span></span><br><span class="line"></span><br><span class="line">        MyInterfaceAbstract.methodStatic();</span><br><span class="line">        <span class="keyword">int</span> a = MyInterfaceAbstract.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol><li>extends继承或则implements实现，是多态性的前提</li><li>一句话可以体现多态：父类引用指向子类对象</li><li>直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找</li><li>成员变量：编译看左边，运行还看左边</li><li>成员方法：编译看左边，运行看右边</li></ol><p>判断 本来的类型<br>animal instanceof Cat</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ol><li>当final关键字用来修饰一个类的时候，这个类就不能有任何的子类</li><li>当final关键字用来修饰一个方法的时候，那个这个方法就是最终方法，不能被覆盖重写</li><li>对于类、方法来说，abstract与final不能同时使用</li><li>final用来修饰一个局部变量，那么这个变量就不能进行更改</li><li>final用来修饰一个成员变量，这个变量也不可变，必须手动赋值，不会再给默认值（直接赋值，或者构造赋值都可以）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>public &gt; protected &gt; (default) &gt; private<br>同一个类 Y Y Y Y<br>同一个包 Y Y Y N<br>不同包子类 Y Y N N<br>不同包非子类 Y N N N</p><p>定义类：<br>外部类：Y Y N N<br>成员内部类： Y Y Y Y<br>局部内部类：什么都不能写</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类：一个类包含另一个类</p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）: 方法里面定义的类</li></ol><p>注意:</p><ul><li>内用外，随意访问；外用内，需要内部类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123; <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">      System.out.println(<span class="string">"心脏跳动"</span>);</span><br><span class="line">      System.out.println(num); <span class="comment">// 30</span></span><br><span class="line">      System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 20</span></span><br><span class="line">      System.out.println(Body.<span class="keyword">this</span>.num); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外部成员变量</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// Java 8+开始，只要局部变量事实不变，那么final关键字可以省略</span></span><br><span class="line">    System.out.println(<span class="string">"外部类的方法"</span>);</span><br><span class="line">    <span class="keyword">new</span> Heart().beat(); </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 局部内部类</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(num); <span class="comment">// 访问所在方法的局部变量，那么这个变量必须是有效final</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">    inner.methodInner();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Body body = <span class="keyword">new</span> Body();</span><br><span class="line">    body.methodBody(); <span class="comment">// 间接调用内部类Heart</span></span><br><span class="line"></span><br><span class="line">    Body.Heart heart = <span class="keyword">new</span> Body().new Heart(); <span class="comment">// 直接调用</span></span><br><span class="line">    heart.beat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类：<br>如果接口的实现类（或则父类的子类）只需使用唯一的一次，那么这种情况就可以省略掉该类的定义，而改为使用【匿名内部类】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyInterface obj = <span class="keyword">new</span> MyInterface() &#123; <span class="comment">// 匿名内部类实现</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"匿名内部类"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>引用类型的一般使用步骤：</p><ol><li><p>导包：<code>import 包路径.类名称</code><br>如果需要使用的目标类，和当前类处于同一个包下，则可以省略导包语句<br>只有java.lang下的内容不需要导包</p></li><li><p>创建：<code>类名称 对象名 = new 类名称()</code></p></li><li><p>使用：<code>对象名.成员方法名()</code></p></li></ol><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>功能：实现键盘输入数据到程序当中</p><p>获取键盘输入的一个int数字：int num = sc.nextInt();<br>获取键盘输入的一个字符串：String str = sc.next();</p><p>从键盘中输入的都是字符串，nextInt() 只是把字符串转为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// System.in：从键盘输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"输入的int数字是："</span>+num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> num1 = r.nextInt() <span class="comment">// 获取一个随机的int数字，包括正负</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="keyword">new</span> r.nextInt(<span class="number">3</span>); <span class="comment">// [0~2) 左闭右开区间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Java程序中的所有字符串字面值（如”abc”）都是String类的对象，不管有没有new</p><ul><li>字符串的内容永不可变</li><li>正是因为字符串不可改变，所以字符串是可以共享使用的</li></ul><p>创建字符串的常见3+1种方式<br>三种构造方法：<br>public String(); 创建一个空白字符串，不含任何内容<br>public String(char[] array); 根据字符数组的内容，来创建对应的字符串<br>public String(byte[] array); 根据字节数组的内容，来创建对应的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(); <span class="comment">// 小括号留空，说明什么都没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] charArr = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span> &#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(charArr); <span class="comment">// "ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] byteArr = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(byteArr); <span class="comment">// "ABC"</span></span><br><span class="line"></span><br><span class="line">String str4 = <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure><p>字符串常量池：程序当中直接写上双引号的字符串，就在字符串常量池中。<br>对于基本类型来说，== 是进行数值的比较<br>对于引用类型来说，== 是进行地址的比较</p><h4 id="String-常见方法"><a href="#String-常见方法" class="headerlink" title="String 常见方法"></a>String 常见方法</h4><ol><li><p>equals()：只有参数是一个字符串并且内容相同才会返回true</p></li><li><p>equalsIgnoreCase(): 忽略大小写</p></li><li><p>length()：字符串当中的字符个数</p></li><li><p>concat(String str)：拼接字符串</p></li><li><p>charAt(int index)：获取指定索引位置的多个字符</p></li><li><p>indexOf(String str)：查找参数字符串首次在本字符串中出现的索引，没有找到返回</p></li></ol><p>-1</p><ol start="7"><li><p>substring(int index)：截取从参数位置一直到字符串末尾</p></li><li><p>substring(int begin, int end)；截取[begin, end)</p></li><li><p>toCharArray()：将当前字符串拆分成为字符数组作为返回值</p></li><li><p>getByte():获取当前字符串底层的字节数组</p></li><li><p>replace(CharSequence oldString, CharSequence newString)：将所有出现的老字符串替换成为新的字符串。返回新结果。CharSequence意思是说可以接受字符串类型</p></li><li><p>split(String regex)：参照参数规则，将字符串切分成为若干部分。参数为正则表达式，若有“.”要这样写“\.”</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span>[] charArr = &#123; <span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span> &#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(charArr); </span><br><span class="line"></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>推荐常量在前：<code>&quot;abc&quot;.equals(str);</code>。因为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">"abc"</span>.equals(str)); <span class="comment">// 推荐：false</span></span><br><span class="line">System.out.println(str.equals(<span class="string">"abc"</span>)); <span class="comment">// 不推荐：报错</span></span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Arrays.toString(数组)，将参数数组变成字符串<br>Arrays.sort(数组)，按照默认升序对数组元素进行排序</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>static double abs(double num)，获得绝对值<br>static double ceil(double num)，向下取整<br>static static double floor(double num)，向下取整<br>static long round(double num)，四舍五入<br>Math.PI</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>所有的类，若没有继承其他父类，默认继承Object类。</p><ol><li>toString，若没有重写，默认打印对象的地址</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">System.out.println(r); <span class="comment">//java.util.Random@3f3afe78</span></span><br></pre></td></tr></table></figure><p>直接打印对象默认调用的是Object的toString方法</p><ol start="2"><li>equals()，判断两个对象的地址值是否相等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line">Random r1 = <span class="keyword">new</span> Random();</span><br><span class="line">Random r2 = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">System.out.println(r1.equals(r2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>null是不能调用方法的，会抛出空指针异常</p><p>Objects.equals(obj1, obj2)：可防止空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects.equals源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>当前系统时间，从1970-1-1 00:00:00 一共经历了多少毫秒<br>System.currentTimeMillis()</p><p><strong>Date(long date)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前系统的日期和时间</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// Tue Aug 11 23:53:37 CST 2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把毫秒转换为Date日期</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">0L</span>); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把日期转为毫秒</span></span><br><span class="line">System.out.println(date.getTime()); <span class="comment">// 1597161217492</span></span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p><strong>java.text.DateFormat抽象类，直接已知子类：SimpleDateFormat</strong></p><ul><li><p>String format(Date date)：按照指定的模式，把Date日期格式化为符合模式的字符串。</p></li><li><p>Date parse(String source)：把符合模式的字符串，解析为Date日期。</p></li><li><p>SimpleDateFormat(String pattern)</p></li><li><p>年/月/日 时:分:秒 yyyy/MM/dd HH:mm:ss</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String text = sdf.format(date); <span class="comment">// 2020-08-11 23:53:37</span></span><br><span class="line"></span><br><span class="line">Date date2 = sdf.parse(<span class="string">"1992-03-12 07:30:43"</span>);</span><br><span class="line">System.out.println(date2); <span class="comment">// Thu Mar 12 07:30:43 CST 1992</span></span><br></pre></td></tr></table></figure><h3 id="Calendar-抽象类"><a href="#Calendar-抽象类" class="headerlink" title="Calendar 抽象类"></a>Calendar 抽象类</h3><p>java.util.Calendar日历抽象类，里面有一个静态方法getInstance()，该方法返回了一个Calendar类的子类对象</p><p>public abstract void add(int field, int amount); // 增加或减少指定的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH);<span class="comment">//西方的月份0-11 东方1-12</span></span><br><span class="line"><span class="keyword">int</span> date = c.tget(Calendar.DATE); <span class="comment">// Calendar.DAY_OF_MONTH</span></span><br><span class="line"></span><br><span class="line">c.set(Calendar.YEAR, <span class="number">1999</span>);</span><br><span class="line">c.set(<span class="number">1992</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加3年</span></span><br><span class="line">c.add(Canlender.add(Calendar.YEAR, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把日历转为日期</span></span><br><span class="line">Date date = c.getTime();</span><br></pre></td></tr></table></figure><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><ul><li><p>System.currentTimeMillis()：获取当前系统毫秒值时间</p></li><li><p>arraycopy(int[] src, int srcIndex, int[] dest, int destIndex, int count)：复制数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liserl.day1.demo09;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    验证for循环打印数字1-9999所需使用的时间（毫秒）</span></span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"程序共耗时："</span> + (e-s) + <span class="string">"毫秒"</span>);</span><br><span class="line">        demo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将src数组中的前3个元素，复制到dest数组的前3个位置上，复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]，复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"复制前："</span> + Arrays.toString(dest));</span><br><span class="line">        System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"复制后："</span> + Arrays.toString(dest));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p><strong>构造函数</strong></p><ul><li>StringBuilder()：构造一个空的字符串缓存区对象</li><li>StringBuilder(String str)：根据传入的内容创建一个字符串缓冲区对象</li></ul><p><strong>成员方法</strong></p><ul><li>StringBuilder append(Object obj)：添加内容</li><li>StringBuilder reverse()：反转内容</li><li>String toString()：将缓存区内容转为字符串</li></ul><p>StringBuilder类：字符串缓冲区，可以提高字符串操作效率（看成一个长度可以变化的字符串）底层也是一个数，如果超出StringBuilder的容量，会自动扩容<br>组，但没有被final修饰，可以改变长度。</p><p>String字符串是常量，底层是一个被final修饰的数组，不能改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// append()可添加任意类型数据类型，返回的是this</span></span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder sb2 = sb1.append(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(sb1 == sb2); <span class="comment">// true，同一块地址</span></span><br><span class="line">        System.out.println(sb1.append(<span class="keyword">true</span>).append(<span class="number">1.2</span>)); <span class="comment">// hellotrue1.2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转StringBuilder</span></span><br><span class="line">        System.out.println(sb1.reverse());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// StringBuilder和String相互转换</span></span><br><span class="line">        String str = <span class="string">"helloworld"</span>;</span><br><span class="line">        StringBuilder sb3 = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        sb3.append(<span class="string">"..."</span>);</span><br><span class="line">        String s = sb1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类：把基本类型的数据包装起来，在包装类中可以定义一些方法，用来操作基本类型的数据</p><table><thead><tr><th align="right">基本类型</th><th align="right">包装类</th></tr></thead><tbody><tr><td align="right">byte</td><td align="right">Byte</td></tr><tr><td align="right">short</td><td align="right">Short</td></tr><tr><td align="right">int</td><td align="right">Integer</td></tr><tr><td align="right">long</td><td align="right">Long</td></tr><tr><td align="right">float</td><td align="right">Float</td></tr><tr><td align="right">double</td><td align="right">Double</td></tr><tr><td align="right">char</td><td align="right">Character</td></tr><tr><td align="right">boolean</td><td align="right">Boolean</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><ul><li>装箱：从基本类型转为对应的包装类对象</li><li>拆箱：从包装类对象转换为对应的基本类型</li></ul><p><strong>自动装箱与自动拆箱</strong></p><p>基本类型的数据和包装类之间可以自动相互转换<br>JDK1.5之后出现的新特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        Integer int1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer int2 = <span class="keyword">new</span> Integer(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法，返回一个表示指定的int值得Integer实例</span></span><br><span class="line">        Integer int3 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = int1.intValue(); <span class="comment">// 拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动装箱，以下相当于：Integer in = new Integer(1);</span></span><br><span class="line">        Integer in = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/*自动拆箱：in是包装类，无法直接参与运算，可以自动转换为基本类型数据，再参与计算</span></span><br><span class="line"><span class="comment">        in + 2 相当于 in.intValue() + 3 = 3;</span></span><br><span class="line"><span class="comment">        in = in + 2 相当于 in = new Integer(3)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        in = in +<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>基本类型 —&gt; 字符串</p><ol><li>基本类型数据的值+ “” （最简单的方式，工作中常用）</li><li>使用包装类中的静态方法：static String toString(int i)</li><li>使用String类中的静态方法：static String valueOf(int i)</li></ol><p>字符串 —&gt; 基本类型</p><ol><li>使用包装类的静态方法：static int parseInt(String s)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="number">100</span> + <span class="string">""</span>;</span><br><span class="line">        System.out.println(s1 + <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        String s2 = Integer.toString(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s2 + <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        String s3 = String.valueOf(<span class="number">100</span>);</span><br><span class="line">        System.out.println(s3 + <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串--&gt;基本类型</span></span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(<span class="string">"100"</span>);</span><br><span class="line">        System.out.println(i + <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><ul><li>集合是java中提供的一种容器，可以用来存储多个数据</li><li>数组的长度是固定的，集合的长度是可变的</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值与对象。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储</li></ul><p>Colection接口常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">boolean add(E e);</td><td align="left">向集合中添加元素</td></tr><tr><td align="left">boolean remove(E e);</td><td align="left">删除集合中的元素</td></tr><tr><td align="left">void clear();</td><td align="left">清空集合所有的元素</td></tr><tr><td align="left">boolean contains(E e);</td><td align="left">判断集合中是否包含某个元素</td></tr><tr><td align="left">boolean isEmpty();</td><td align="left">判断集合是否为空</td></tr><tr><td align="left">int size();</td><td align="left">获取集合的长度</td></tr><tr><td align="left">Object[] toArray();</td><td align="left">将集合转成一个数组</td></tr></tbody></table><p>List子接口</p><ol><li>有序的集合（存储和取出顺序相同）</li><li>允许存储重复的元素</li><li>有索引，可以使用普通的for循环遍历</li><li>子类集合：Vector、ArrayList、LinkedList</li></ol><p>Set子接口</p><ol><li>不允许存储重复元素</li><li>没有索引（不能用普通的for循环遍历）</li><li>子类集合：TreeSet、HashSet &lt;- LinkedHashSet</li></ol><p><img src="/blog/2020/06/10/java/java/colleciton.png" alt="collection"></p><h2 id="Iterator接口-迭代器"><a href="#Iterator接口-迭代器" class="headerlink" title="Iterator接口 迭代器"></a>Iterator接口 迭代器</h2><p>主要用于迭代访问（即遍历）Colecition中的元素</p><p>boolean hasNext() : 如果仍有元素可以迭代，则返回true<br>E next() 返回迭代的下一个元素</p><p>Collection接口中有一个方法iterator()，返回的是迭代器的实现类对象</p><p><strong>增强for</strong></p><p>增强for循环（也称for each循环）是JDK1.5后出现的高级for循环，专门用来遍历数组和集合。它的内部原理是个Iterator迭代器,所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">"Piter"</span>);</span><br><span class="line">        coll.add(<span class="string">"Tom"</span>);</span><br><span class="line">        coll.add(<span class="string">"Jone"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(String s : coll) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line">GenericClass&lt;Integer&gt; gc = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">gc.setName(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>定义含有泛型的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><a data-url="https://liserlzhy.github.io/2020/06/10/java/java/" data-id="ckmuo0p7m001fzssfdb5v7gme" class="article-share-link">Share</a></footer></div><nav id="article-nav"><a href="/blog/2020/05/16/node/pm2/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">pm2线上部署</div></a></nav></article></div><section id="comments"><div id="gitalk-container"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><div id="gitalk-container"></div><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"c384627b91fb67b4d945",clientSecret:"40bcd6212e102325b854bae964674349cc49d136",id:window.location.pathname,repo:"blog-comment",owner:"liserlzhy",admin:"liserlzhy"});gitalk.render("gitalk-container")</script></section><span id="toTopBtn" class="icon icon-angle-up"></span></div><footer id="footer"><div id="right-footer"><div id="social-media-footer"><ul><li><a href="https://github.com/liserlzhy/blog" target="_blank" rel="noopener" class="icon icon-github"></a></li></ul></div></div></footer></div></div><script src="/blog/js/jquery.min.js"></script><link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css"><script src="/blog/fancybox/jquery.fancybox.pack.js"></script><script src="/blog/js/script.js"></script><script src="/blog/js/search.js"></script><script type="text/javascript">var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/blog/"+search_path;searchFunc(path,"slidedown-search-input","slidedown-search-result"),searchFunc(path,"nav-search-input","nav-search-result")</script></body><!-- rebuild by neat -->