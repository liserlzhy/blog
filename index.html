<!-- build time:Fri May 22 2020 10:50:00 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html><head><meta charset="utf-8"><title>Zhy Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:type" content="website"><meta property="og:title" content="Zhy Blog"><meta property="og:url" content="https:&#x2F;&#x2F;liserlzhy.github.io&#x2F;index.html"><meta property="og:site_name" content="Zhy Blog"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><link rel="alternate" href="/blog/atom.xml" title="Zhy Blog" type="application/atom+xml"><link rel="icon" href="/blog/css/images/logo.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/blog/css/style.css"><meta name="generator" content="Hexo 4.0.0"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="slideout-menu"><ul><li><a class="main-nav-link" href="/blog/">首页</a></li><li><a class="main-nav-link" href="/blog/archives">归档</a></li><li><a class="main-nav-link" href="/blog/favorite">收藏</a></li><li><div class="site_search"><div class="form-group"><input type="text" id="slidedown-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"></div><div id="slidedown-search-result"></div></div></li></ul></div><nav id="header-nav"><div id="logo-img"><label class="on-off noselect" for="on-off"><input id="on-off" type="checkbox" onchange='return window.location="/blog/"'> <span class="on-off-circle"></span></label></div><div id="menu-icon"><a class="icon icon-bars"></a></div><ul><li><a class="main-nav-link" href="/blog/">首页</a></li><li><a class="main-nav-link" href="/blog/archives">归档</a></li><li><a class="main-nav-link" href="/blog/favorite">收藏</a></li><li><div id="search-icon"><a class="icon icon-search" title="搜索"></a></div></li></ul></nav><div class="site_search"><div><input type="text" id="nav-search-input" name="q" results="0" placeholder="搜索"></div><div id="nav-search-result"></div></div></header><div class="outer"><section id="main"><div><article id="post-node/pm2" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><time class="article-date" datetime="2020-05-16T17:27:04.000Z" itemprop="datePublished">2020-05-16</time><div class="article-category"><a class="article-category-link" href="/blog/categories/node/">node</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/blog/2020/05/16/node/pm2/">pm2线上部署</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><h3 id="ssh免密登录到服务器"><a href="#ssh免密登录到服务器" class="headerlink" title="ssh免密登录到服务器"></a>ssh免密登录到服务器</h3><ol><li>本地生成密钥对</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;xxx@qq.com&apos;</span><br><span class="line"></span><br><span class="line"># -t 指定密钥类型，可省略</span><br><span class="line"># -C 注释文字，可省略</span><br></pre></td></tr></table></figure><p class="article-more-link"><a href="/blog/2020/05/16/node/pm2/#more">Read More</a></p></div><footer class="article-footer"><a data-url="https://liserlzhy.github.io/2020/05/16/node/pm2/" data-id="ckai31c9r000c2sl2faqwb5q7" class="article-share-link">Share</a></footer></div></article></div><div><article id="post-others/typescript" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><time class="article-date" datetime="2020-01-18T16:15:39.000Z" itemprop="datePublished">2020-01-18</time><div class="article-category"><a class="article-category-link" href="/blog/categories/others/">others</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/blog/2020/01/18/others/typescript/">TypeScript</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>1、安装 TypeScript 编译器</p><pre><code>npm i typescript -g</code></pre><p>TypeScript 是 JavaScript 的超集，添加了可选的静态类型和基于类的面向对象编程。所以 TypeScript 代码在浏览器/Node环境下运行，需要把 TypeScript 代码编译为 JavaScript 代码</p><p>2、编译命令</p><pre><code>./node_modules/bin/tsc ./src/1.ts --outDir ./dist</code></pre><p>3、配置文件 ( tsconfig.json )</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>, </span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es2017"</span>,</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist"</span>, </span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noImplicitThis"</span>: <span class="literal">true</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [ </span><br><span class="line">    <span class="string">"./src/**/*"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><p><code>compilerOtions</code></p><ul><li><code>module</code>: 指定编译后的代码要使用的模块化系统，注意：只有”AMD”和”System”能和outFile一起使用</li><li><code>target</code>: 指定编译后的代码对应的 ECMAScript版本</li><li><code>outDir</code>: 指定编译后的代码文件输出目录</li><li><code>outFile</code>: 将输出文件合并成一个文件 (合并的文件顺序为加载和依赖顺序)</li><li><code>strictNullChecks</code>: 严格模式</li></ul><p><code>include</code>: 指定要编译的文件目录，若不指定会编译该目录下所有的TypeScript文件，可使用 glob 匹配模式，例如：* 匹配0或则多个字符，?匹配一个任意字符，**/匹配任意子目录</p><p>配置完成后，直接输入<code>./node_modules/bin/tsc</code> 它会自动编译ts文件</p><p>注意： ts-node 模块可以编译并运行TypeScript文件</p><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>类型注解（类型声明、类型约束）</p><p>JavaScript 是动态语言，变量随时可以被赋予不同类型的值，变量值得类型只有在运行时才能决定</p><p>使用类型注解能够在变量声明的时候确定变量存储的值的类型，用来约束变量或参数值的类型，这样在编码阶段就可以检查出可能出现的问题，避免把错误带到执行期间</p><p>语法：</p><pre><code>let 变量:类型</code></pre><p>当变量接收了与定义的类型不符的数据会导致编译失败（警告）</p><p>基本类型：string、number、boolean<br>对象类型：String、Number、Boolean</p><p>注意：基本类型可以赋值给对应包装对象，包装对象不可以复制给对应基本类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s:<span class="built_in">String</span> = <span class="string">'typescript'</span></span><br><span class="line"><span class="keyword">let</span> s:<span class="built_in">string</span> = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'typescript'</span>) <span class="comment">// 该语句会报错</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>基本语法：<code>let list: number[];</code><br>泛型方式：<code>let list: Array&lt;number&gt;;</code></p><p>注意：该数组是具有相同类型的一组有序数据的集合，声明数组的同时要确定数据存储的数据类型</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>];</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 一定得是number类型</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="string">'2'</span>; </span><br><span class="line">data[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">data[<span class="number">3</span>] = <span class="number">10</span>; <span class="comment">// number,string,boolean 随便一种类型都可以</span></span><br><span class="line"><span class="comment">// 注意：数据类型要对应定义的顺序， 越界部分，采用联合类型</span></span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: stirng|<span class="built_in">number</span>; <span class="comment">// 可存储string或number类型的数据</span></span><br></pre></td></tr></table></figure><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">string</span>&amp;<span class="built_in">number</span> = &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender &#123;mail, femail&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Gender.mail)</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型</p><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// ts会根据变量初始化的时候根据赋予的值进行类型判断 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 事件函数的第一个参数，根据当前绑定的事件类型推导(e:MouseEvent)</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>对函数的参数和返回值进行类型约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据类型推断可简写为</span></span><br><span class="line"><span class="keyword">let</span> fn2: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line">fn2(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 如果函数没有返回值 :void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可选参数 ? */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数默认值 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span>(<span class="params">x = 1</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x * x &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 剩余参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params">...arg: <span class="built_in">any</span>[]</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数重载 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数中的-this"><a href="#函数中的-this" class="headerlink" title="函数中的 this"></a>函数中的 this</h3><ul><li>ts 中函数中的 this 默认指向类型 : any （除了事件函数）</li><li>any类型不能指示任何属性方法</li><li>我们可以通过 <code>--nolmplicitThis</code> 选项来取消this的默认any类型设置</li><li>ts 会自动推导事件函数中的 this</li><li>在ts中函数的第一个this参数是用来设置 this 类型约束的，该this参数是个假参数，运行过程中是不存在的，是给ts检测使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn(<span class="keyword">this</span>: Document|Element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.querySelecter()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onclick = obj1.fn;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>与 ES2015 的 class 类似，同时还新添了一些特性，TS 中的成员属性可以提取到构造函数以外进行定义</p><p>通过修饰符可以对类中成员属性与成员方法进行访问控制：</p><ul><li>public : 公开的，所有地方都能访问，属性和方法默认是public</li><li>protected : 受保护的，在类的内部和他的子类中才能访问</li><li>private : 私有的，只能在该对象（类）的内部才可以访问</li><li>readonly : 只读</li></ul><p>存取器：getters/setters 截取对对象成员的访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts类中的成员属性必须要声明后使用</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  username: <span class="built_in">string</span> = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存取器，属性方式去访问</span></span><br><span class="line">  <span class="keyword">get</span> age(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> age(age: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>如果子类没有重写构造函数，会直接继承父类的，否则需要手动调用父类构造函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">username: <span class="built_in">string</span>, age: <span class="built_in">number</span>, <span class="keyword">public</span> grade: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(username age); <span class="comment">// 执行父类构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象方法只定义结构不定义具体实现。</li><li>拥有抽象方法的类必须是抽象类，但抽象类不一定拥有抽象方法，抽象类中也可以包含其他非抽象方法。</li><li>抽象类不能被实例化。</li><li>继承抽象类的类必须实现抽象类中的所有方法，否则该子类也必须声明为抽象的。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> username: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> study(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  study() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i am studing something new.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>为我们提供一种方式来定义某种结构，ts按照这种结构来检测数据</li><li>接口中定义的规则只有抽象描述，不能有具体实现</li><li>类型检查器只会检测必须的属性是否存在，以及类型是否匹配，不会检查属性的顺序<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>,</span><br><span class="line">  height: <span class="built_in">number</span>, <span class="comment">// 比选属性</span></span><br><span class="line">  color?: <span class="built_in">string</span>, <span class="comment">// 可选属性</span></span><br><span class="line">  <span class="comment">// readonly name: string // 只读属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">opts: Options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绕开类型检测 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 告知ts检测，传入的就是一个 Options</span></span><br><span class="line">fn(&#123; height: <span class="number">200</span> &#125; <span class="keyword">as</span> Options) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 先赋值给一个变量，也可以绕开检测</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; height: <span class="number">100</span>, width: <span class="number">20</span>, color: <span class="string">'red'</span>, a: <span class="number">1</span>&#125;</span><br><span class="line">fn(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引签名：希望规则是一组由数字进行key命名的对象</span></span><br><span class="line"><span class="comment">// 索引key类型只能是string或number， string 也支持number key</span></span><br><span class="line"><span class="keyword">interface</span> Options2 &#123;</span><br><span class="line">  [attr: <span class="built_in">number</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接口</span></span><br><span class="line"><span class="keyword">interface</span> IFn &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类接口"><a href="#类接口" class="headerlink" title="类接口"></a>类接口</h3><ul><li>继承接口的类必须拥有接口定义的属性和方法</li><li>一个类只能继承一个类，但是可以实现多个接口</li><li>接口之间也可以继承</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISuper &#123;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Man&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">pubic name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SuperMan  <span class="keyword">extends</span> Man <span class="keyword">implements</span> ISuper&#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i can fly'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>通常我们会使用变量来表示是一个可变的值，通过变量我们就可以使代码具有很高的可重用性，但是在有类型约束的语言中，有时候不利于代码的复用，通过使用泛型，我们就可以解决这个问题，简单的理解可以说是给类型定义变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T[]</span>): <span class="title">T</span>[]</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn&lt;<span class="built_in">string</span>&gt;([<span class="string">'s'</span>, <span class="string">'1'</span>])</span><br><span class="line"><span class="keyword">class</span> MyArray &lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> _data: T[] = [];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类类型 &#123;new()&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_</span>(<span class="params">constructor: &#123;<span class="keyword">new</span>(): <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">constructor</span>(<span class="params"></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在尽可能不改变类（对象）结构的情况下，扩展其功能。装饰器是一种特殊类型的声明，它可以被附加到类声明、属性、方法、参数或访问符上。</p><p>启动装饰器模式：–experimentalDecorators</p><p>装饰器函数：<br>我们要在一个类或方法上使用装饰器，首先需要提供一个装饰器函数，这个函数会在该装饰器被使用的时候调用</p><p>1、类装饰器：<br>类装饰器应用于构造函数，可以用来监视、修改或替换类定义，类的构造函数会作为类装饰器函数的唯一一个参数</p><pre><code>function f(constructor: Function) {}</code></pre><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Age</span>(<span class="params">v: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;<span class="keyword">new</span>(...args: <span class="built_in">any</span>[]): &#123;&#125;&#125;&gt;(<span class="keyword">constructor</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">class</span> Person2 <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</span><br><span class="line">      age: <span class="built_in">number</span> = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Person2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Age是一个装饰器函数，该函数会自动调用。调用的时候会传入对应类的构造函数</span></span><br><span class="line"><span class="comment">// 如果希望转入构造值，就得使用闭包</span></span><br><span class="line"><span class="meta">@Age</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  username = <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Person2 &#123;username: 'Tom', age: 20 &#125;</span></span><br></pre></td></tr></table></figure><p>2、方法装饰器：<br>用来监视、修改或替换方法定义，方法装饰器会在调用时传入下列三个参数</p><ul><li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象</li><li>成员的名称</li><li>成员属性描述符</li></ul><p>3、访问器装饰器<br>访问器：get、set，访问器装饰器会在调用时传入下列3个参数：</p><ul><li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象</li><li>成员的名称</li><li>成员属性描述符</li></ul><p>注意：不允许同时修饰一个成员的get和set服务器。一个成员的所有装饰必须应用在文档顺序的第一个访问器上</p><p>4、参数装饰器<br>参数装饰器声明在一个参数声明之前，参数装饰器只能用来监视一个方法的参数是否被传入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: HTMLInputElement = <span class="built_in">document</span>.querySelector(<span class="string">'.val'</span>);</span><br><span class="line"><span class="keyword">let</span> btn: HTMLButtonElement = documentSelector(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value: <span class="built_in">number</span> = <span class="built_in">Number</span>(input.value) + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><a data-url="https://liserlzhy.github.io/2020/01/18/others/typescript/" data-id="ckai31ca700142sl24cgv82tc" class="article-share-link">Share</a></footer></div></article></div><div><article id="post-database/mysql" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><time class="article-date" datetime="2019-12-30T09:01:16.000Z" itemprop="datePublished">2019-12-30</time><div class="article-category"><a class="article-category-link" href="/blog/categories/database/">database</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/blog/2019/12/30/database/mysql/">mysql</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎：数据在计算机上存储的方式</p><p>MySQL 常见的存储引擎：InnoDB、MyISAM等</p><ul><li><p>InnoDB 的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大</p></li><li><p>MyISAM 的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性</p></li></ul><p class="article-more-link"><a href="/blog/2019/12/30/database/mysql/#more">Read More</a></p></div><footer class="article-footer"><a data-url="https://liserlzhy.github.io/2019/12/30/database/mysql/" data-id="ckai31ca600122sl238207rzl" class="article-share-link">Share</a></footer></div></article></div><div><article id="post-vue/vue-core" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><time class="article-date" datetime="2019-12-28T21:16:06.000Z" itemprop="datePublished">2019-12-28</time><div class="article-category"><a class="article-category-link" href="/blog/categories/Vue/">Vue</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/blog/2019/12/28/vue/vue-core/">vue 的核心原理</a></h1></header><div class="article-entry" itemprop="articleBody"><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>作用：直接在一个对象上定义一个新属性，或者修改一个对象现有的属性</p><p>语法：Object.defineProperty(obj, prop, descriptor)</p><p>descriptor 为被定义或修改的描述符</p><ul><li>数据描述<ul><li><code>configurable</code> : 是否可以被删除，默认 false</li><li><code>enumerable</code> : 是否可以被枚举， 默认 false</li><li><code>value</code> : 属性的值，默认为 undefined</li><li><code>writable</code> : 是否可以被重写， 默认 false</li></ul></li><li>访问器描述<ul><li>getter : 获取属性值得方法</li><li>setter: 设置属性值得方法</li><li>注意：可以写 configurable, enumerable, 不能写 value, writable</li></ul></li></ul><p class="article-more-link"><a href="/blog/2019/12/28/vue/vue-core/#more">Read More</a></p></div><footer class="article-footer"><a data-url="https://liserlzhy.github.io/2019/12/28/vue/vue-core/" data-id="ckai31c9x000j2sl2hvjiff90" class="article-share-link">Share</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Vue/" rel="tag">Vue</a></li></ul></footer></div></article></div><div><article id="post-database/mongodb" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><time class="article-date" datetime="2019-12-22T23:28:48.000Z" itemprop="datePublished">2019-12-22</time><div class="article-category"><a class="article-category-link" href="/blog/categories/database/">database</a></div></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/blog/2019/12/22/database/mongodb/">mongodb</a></h1></header><div class="article-entry" itemprop="articleBody"><p>启动数据库服务</p><pre><code>mongod</code></pre><p>开启mongo客户端</p><pre><code>mongo --dbpath=C:/data</code></pre><p class="article-more-link"><a href="/blog/2019/12/22/database/mongodb/#more">Read More</a></p></div><footer class="article-footer"><a data-url="https://liserlzhy.github.io/2019/12/22/database/mongodb/" data-id="ckai31ca500112sl2gmfo36eu" class="article-share-link">Share</a></footer></div></article></div><nav id="page-nav"><span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">下一页</a></nav></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">分类</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/browser/">browser</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/computer/">computer</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/database/">database</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/others/">others</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/node-api/" rel="tag">node api</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/blog/tags/Vue/" style="font-size:10px">Vue</a> <a href="/blog/tags/git/" style="font-size:10px">git</a> <a href="/blog/tags/node-api/" style="font-size:20px">node api</a></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">八月 2019</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li><a href="/blog/2020/05/16/node/pm2/">pm2线上部署</a></li><li><a href="/blog/2020/01/18/others/typescript/">TypeScript</a></li><li><a href="/blog/2019/12/30/database/mysql/">mysql</a></li><li><a href="/blog/2019/12/28/vue/vue-core/">vue 的核心原理</a></li><li><a href="/blog/2019/12/22/database/mongodb/">mongodb</a></li></ul></div></div></aside><span id="toTopBtn" class="icon icon-angle-up"></span></div><footer id="footer"><div id="right-footer"><div id="social-media-footer"><ul><li><a href="https://github.com/liserlzhy/blog" target="_blank" rel="noopener" class="icon icon-github"></a></li></ul></div></div></footer></div></div><script src="/blog/js/jquery.min.js"></script><link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css"><script src="/blog/fancybox/jquery.fancybox.pack.js"></script><script src="/blog/js/script.js"></script><script src="/blog/js/search.js"></script><script type="text/javascript">var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/blog/"+search_path;searchFunc(path,"slidedown-search-input","slidedown-search-result"),searchFunc(path,"nav-search-input","nav-search-result")</script></body><!-- rebuild by neat -->